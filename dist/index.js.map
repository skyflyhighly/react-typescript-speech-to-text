{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/wildemitter/wildemitter.js","../node_modules/hark/hark.js","../node_modules/inline-worker/index.js","../src/Hooks/recorder.js","../src/Hooks/recorderHelpers.js","../src/Hooks/index.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n","var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n","var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\n\nfunction InlineWorker(func, self) {\n  var _this = this;\n  var functionBody;\n\n  self = self || {};\n\n  if (WORKER_ENABLED) {\n    functionBody = func.toString().trim().match(\n      /^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/\n    )[1];\n\n    return new global.Worker(global.URL.createObjectURL(\n      new global.Blob([ functionBody ], { type: \"text/javascript\" })\n    ));\n  }\n\n  function postMessage(data) {\n    setTimeout(function() {\n      _this.onmessage({ data: data });\n    }, 0);\n  }\n\n  this.self = self;\n  this.self.postMessage = postMessage;\n\n  setTimeout(func.bind(self, self), 0);\n}\n\nInlineWorker.prototype.postMessage = function postMessage(data) {\n  var _this = this;\n\n  setTimeout(function() {\n    _this.self.onmessage({ data: data });\n  }, 0);\n};\n\nmodule.exports = InlineWorker;\n","import InlineWorker from 'inline-worker';\r\n\r\nexport class Recorder {\r\n  constructor(source, cfg) {\r\n    this.config = {\r\n      bufferLen: 4096,\r\n      numChannels: 1,\r\n      mimeType: 'audio/wav',\r\n      ...cfg\r\n    };\r\n    this.recording = false;\r\n    this.callbacks = {\r\n      getBuffer: [],\r\n      exportWAV: []\r\n    };\r\n    this.context = source.context;\r\n    this.node = (\r\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\r\n    ).call(\r\n      this.context,\r\n      this.config.bufferLen,\r\n      this.config.numChannels,\r\n      this.config.numChannels\r\n    );\r\n\r\n    this.node.onaudioprocess = (e) => {\r\n      if (!this.recording) return;\r\n\r\n      var buffer = [];\r\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\r\n        buffer.push(e.inputBuffer.getChannelData(channel));\r\n      }\r\n      this.worker.postMessage({\r\n        command: 'record',\r\n        buffer: buffer\r\n      });\r\n    };\r\n\r\n    source.connect(this.node);\r\n    this.node.connect(this.context.destination); //this should not be necessary\r\n\r\n    let self = {};\r\n    this.worker = new InlineWorker(function () {\r\n      let recLength = 0,\r\n        recBuffers = [],\r\n        sampleRate,\r\n        numChannels;\r\n\r\n      this.onmessage = function (e) {\r\n        switch (e.data.command) {\r\n          case 'init':\r\n            init(e.data.config);\r\n            break;\r\n          case 'record':\r\n            record(e.data.buffer);\r\n            break;\r\n          case 'exportWAV':\r\n            exportWAV(e.data.type);\r\n            break;\r\n          case 'getBuffer':\r\n            getBuffer();\r\n            break;\r\n          case 'clear':\r\n            clear();\r\n            break;\r\n        }\r\n      };\r\n\r\n      let newSampleRate;\r\n\r\n      function init(config) {\r\n        sampleRate = config.sampleRate;\r\n        numChannels = config.numChannels;\r\n        initBuffers();\r\n\r\n        if (sampleRate > 48000) {\r\n          newSampleRate = 48000;\r\n        } else {\r\n          newSampleRate = sampleRate;\r\n        }\r\n      }\r\n\r\n      function record(inputBuffer) {\r\n        for (var channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel].push(inputBuffer[channel]);\r\n        }\r\n        recLength += inputBuffer[0].length;\r\n      }\r\n\r\n      function exportWAV(type) {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        let interleaved;\r\n        if (numChannels === 2) {\r\n          interleaved = interleave(buffers[0], buffers[1]);\r\n        } else {\r\n          interleaved = buffers[0];\r\n        }\r\n\r\n        // converts sample rate to 48000 if higher than 48000\r\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\r\n\r\n        let dataview = encodeWAV(downSampledBuffer);\r\n        let audioBlob = new Blob([dataview], { type: type });\r\n\r\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\r\n      }\r\n\r\n      function getBuffer() {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        this.postMessage({ command: 'getBuffer', data: buffers });\r\n      }\r\n\r\n      function clear() {\r\n        recLength = 0;\r\n        recBuffers = [];\r\n        initBuffers();\r\n      }\r\n\r\n      function initBuffers() {\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel] = [];\r\n        }\r\n      }\r\n\r\n      function mergeBuffers(recBuffers, recLength) {\r\n        let result = new Float32Array(recLength);\r\n        let offset = 0;\r\n        for (let i = 0; i < recBuffers.length; i++) {\r\n          result.set(recBuffers[i], offset);\r\n          offset += recBuffers[i].length;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function interleave(inputL, inputR) {\r\n        let length = inputL.length + inputR.length;\r\n        let result = new Float32Array(length);\r\n\r\n        let index = 0,\r\n          inputIndex = 0;\r\n\r\n        while (index < length) {\r\n          result[index++] = inputL[inputIndex];\r\n          result[index++] = inputR[inputIndex];\r\n          inputIndex++;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function floatTo16BitPCM(output, offset, input) {\r\n        for (let i = 0; i < input.length; i++, offset += 2) {\r\n          let s = Math.max(-1, Math.min(1, input[i]));\r\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n        }\r\n      }\r\n\r\n      function writeString(view, offset, string) {\r\n        for (let i = 0; i < string.length; i++) {\r\n          view.setUint8(offset + i, string.charCodeAt(i));\r\n        }\r\n      }\r\n\r\n      // Down sample buffer before WAV encoding\r\n      function downSampleBuffer(buffer, rate) {\r\n        if (rate == sampleRate) {\r\n          return buffer;\r\n        }\r\n        if (rate > sampleRate) {\r\n          throw 'downsampling rate show be smaller than original sample rate';\r\n        }\r\n        var sampleRateRatio = sampleRate / rate;\r\n        var newLength = Math.round(buffer.length / sampleRateRatio);\r\n        var result = new Float32Array(newLength);\r\n        var offsetResult = 0;\r\n        var offsetBuffer = 0;\r\n        while (offsetResult < result.length) {\r\n          var nextOffsetBuffer = Math.round(\r\n            (offsetResult + 1) * sampleRateRatio\r\n          );\r\n          // Use average value of skipped samples\r\n          var accum = 0,\r\n            count = 0;\r\n          for (\r\n            var i = offsetBuffer;\r\n            i < nextOffsetBuffer && i < buffer.length;\r\n            i++\r\n          ) {\r\n            accum += buffer[i];\r\n            count++;\r\n          }\r\n          result[offsetResult] = accum / count;\r\n          // Or you can simply get rid of the skipped samples:\r\n          // result[offsetResult] = buffer[nextOffsetBuffer];\r\n          offsetResult++;\r\n          offsetBuffer = nextOffsetBuffer;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function encodeWAV(samples) {\r\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\r\n        let view = new DataView(buffer);\r\n\r\n        /* RIFF identifier */\r\n        writeString(view, 0, 'RIFF');\r\n        /* RIFF chunk length */\r\n        view.setUint32(4, 36 + samples.length * 2, true);\r\n        /* RIFF type */\r\n        writeString(view, 8, 'WAVE');\r\n        /* format chunk identifier */\r\n        writeString(view, 12, 'fmt ');\r\n        /* format chunk length */\r\n        view.setUint32(16, 16, true);\r\n        /* sample format (raw) */\r\n        view.setUint16(20, 1, true);\r\n        /* channel count */\r\n        view.setUint16(22, numChannels, true);\r\n        /* sample rate */\r\n        view.setUint32(24, newSampleRate, true);\r\n        /* byte rate (sample rate * block align) */\r\n        view.setUint32(28, newSampleRate * 4, true);\r\n        /* block align (channel count * bytes per sample) */\r\n        view.setUint16(32, numChannels * 2, true);\r\n        /* bits per sample */\r\n        view.setUint16(34, 16, true);\r\n        /* data chunk identifier */\r\n        writeString(view, 36, 'data');\r\n        /* data chunk length */\r\n        view.setUint32(40, samples.length * 2, true);\r\n\r\n        floatTo16BitPCM(view, 44, samples);\r\n\r\n        return view;\r\n      }\r\n    }, self);\r\n\r\n    this.worker.postMessage({\r\n      command: 'init',\r\n      config: {\r\n        sampleRate: this.context.sampleRate,\r\n        numChannels: this.config.numChannels\r\n      }\r\n    });\r\n\r\n    this.worker.onmessage = (e) => {\r\n      let cb = this.callbacks[e.data.command].pop();\r\n      if (typeof cb == 'function') {\r\n        cb(e.data.data);\r\n      }\r\n    };\r\n  }\r\n\r\n  record() {\r\n    this.recording = true;\r\n  }\r\n\r\n  stop() {\r\n    this.recording = false;\r\n  }\r\n\r\n  clear() {\r\n    this.worker.postMessage({ command: 'clear' });\r\n  }\r\n\r\n  getBuffer(cb) {\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error('Callback not set');\r\n\r\n    this.callbacks.getBuffer.push(cb);\r\n\r\n    this.worker.postMessage({ command: 'getBuffer' });\r\n  }\r\n\r\n  exportWAV(cb, mimeType) {\r\n    mimeType = mimeType || this.config.mimeType;\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error('Callback not set');\r\n\r\n    this.callbacks.exportWAV.push(cb);\r\n\r\n    this.worker.postMessage({\r\n      command: 'exportWAV',\r\n      type: mimeType\r\n    });\r\n  }\r\n\r\n  static forceDownload(blob, filename) {\r\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\r\n    let link = window.document.createElement('a');\r\n    link.href = url;\r\n    link.download = filename || 'output.wav';\r\n    let click = document.createEvent('Event');\r\n    click.initEvent('click', true, true);\r\n    link.dispatchEvent(click);\r\n  }\r\n}\r\n\r\nexport default Recorder;\r\n","import Recorder from './recorder';\r\n\r\nlet microphoneStream; // stream from getUserMedia()\r\nlet rec = Recorder; // Recorder.js object\r\nlet input; // MediaStreamAudioSourceNode we'll be recording\r\n\r\n/**\r\n *\r\n * @param {{\r\n * audioContext: AudioContext\r\n * errHandler?: () => void\r\n * onStreamLoad?: () => void\r\n * }}\r\n * @returns {Promise<MediaStream>}\r\n */\r\nexport async function startRecording({\r\n  audioContext,\r\n  errHandler,\r\n  onStreamLoad,\r\n}) {\r\n  try {\r\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n    if (onStreamLoad) {\r\n      onStreamLoad();\r\n    }\r\n\r\n    /*  assign stream for later use  */\r\n    microphoneStream = stream;\r\n\r\n    /* use the stream */\r\n    input = audioContext.createMediaStreamSource(stream);\r\n\r\n    rec = new Recorder(input);\r\n\r\n    // start the recording process\r\n    rec.record();\r\n\r\n    return stream;\r\n  } catch (err) {\r\n    console.log(err);\r\n\r\n    if (errHandler) {\r\n      errHandler();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {{\r\n * exportWAV: boolean\r\n * wavCallback?: (blob: Blob) => void\r\n * }}\r\n */\r\nexport function stopRecording({ exportWAV, wavCallback }) {\r\n  // stop recorder.js recording\r\n  rec.stop();\r\n\r\n  // stop microphone access\r\n  microphoneStream.getAudioTracks()[0].stop();\r\n\r\n  // create the wav blob\r\n  if (exportWAV && wavCallback) {\r\n    rec.exportWAV((blob) => wavCallback(blob));\r\n  }\r\n\r\n  rec.clear();\r\n}\r\n","import { useState, useEffect, useRef } from 'react';\r\nimport Hark from 'hark';\r\nimport { startRecording, stopRecording } from './recorderHelpers';\r\n\r\nconst isEdgeChromium = navigator.userAgent.indexOf('Edg/') !== -1;\r\n\r\ninterface BraveNavigator extends Navigator {\r\n  brave: {\r\n    isBrave: () => Promise<boolean>;\r\n  };\r\n}\r\n\r\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\r\n\r\nconst SpeechRecognition =\r\n  window.SpeechRecognition || (window as any).webkitSpeechRecognition;\r\n\r\nlet recognition: SpeechRecognition | null;\r\n\r\n// Set recognition back to null for brave browser due to promise resolving\r\n// after the conditional on line 31\r\nif ((navigator as BraveNavigator).brave) {\r\n  (navigator as BraveNavigator).brave.isBrave().then((bool) => {\r\n    if (bool) recognition = null;\r\n  });\r\n}\r\n\r\n// Chromium browsers will have the SpeechRecognition method\r\n// but do not implement the functionality due to google wanting 💰\r\n// this covers new Edge and line 22 covers Brave, the two most popular non-chrome chromium browsers\r\nif (!isEdgeChromium && SpeechRecognition) {\r\n  recognition = new SpeechRecognition();\r\n}\r\n\r\nexport interface UseSpeechToTextTypes {\r\n  continuous?: boolean;\r\n  crossBrowser?: boolean;\r\n  googleApiKey?: string;\r\n  onStartSpeaking?: () => any;\r\n  onStoppedSpeaking?: () => any;\r\n  timeout?: number;\r\n}\r\n\r\nexport default function useSpeechToText({\r\n  continuous,\r\n  crossBrowser,\r\n  googleApiKey,\r\n  onStartSpeaking,\r\n  onStoppedSpeaking,\r\n  timeout\r\n}: UseSpeechToTextTypes) {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n\r\n  const audioContextRef = useRef<AudioContext>();\r\n\r\n  const [results, setResults] = useState<string[]>([]);\r\n  const [error, setError] = useState('');\r\n\r\n  const timeoutId = useRef<number>();\r\n  const mediaStream = useRef<MediaStream>();\r\n\r\n  useEffect(() => {\r\n    if (!crossBrowser && !recognition) {\r\n      setError('Speech Recognition API is only available on Chrome');\r\n    }\r\n\r\n    if (!navigator?.mediaDevices?.getUserMedia) {\r\n      setError('getUserMedia is not supported on this device/browser :(');\r\n    }\r\n\r\n    if (!audioContextRef.current) {\r\n      audioContextRef.current = new AudioContext();\r\n    }\r\n  }, []);\r\n\r\n  // Chrome Speech Recognition API:\r\n  // Only supported on Chrome browsers\r\n  const chromeSpeechRecognition = () => {\r\n    if (recognition) {\r\n      // Continuous recording after stopped speaking event\r\n      if (continuous) recognition.continuous = true;\r\n\r\n      // start recognition\r\n      recognition.start();\r\n\r\n      // speech successfully translated into text\r\n      recognition.onresult = (e) => {\r\n        if (e.results) {\r\n          setResults((prevResults) => [\r\n            ...prevResults,\r\n            e.results[e.results.length - 1][0].transcript\r\n          ]);\r\n        }\r\n      };\r\n\r\n      recognition.onaudiostart = () => setIsRecording(true);\r\n\r\n      // Audio stopped recording or timed out.\r\n      // Chrome speech auto times-out if no speech after a while\r\n      recognition.onaudioend = () => {\r\n        setIsRecording(false);\r\n      };\r\n    }\r\n  };\r\n\r\n  const startSpeechToText = async () => {\r\n    if (recognition) {\r\n      chromeSpeechRecognition();\r\n      return;\r\n    }\r\n\r\n    if (!crossBrowser) {\r\n      return;\r\n    }\r\n\r\n    // Resume audio context due to google auto play policy\r\n    // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio\r\n    if (audioContextRef.current?.state === 'suspended') {\r\n      audioContextRef.current?.resume();\r\n    }\r\n\r\n    const stream = await startRecording({\r\n      errHandler: () => setError('Microphone permission was denied'),\r\n      audioContext: audioContextRef.current as AudioContext\r\n    });\r\n\r\n    // Stop recording if timeout\r\n    if (timeout) {\r\n      handleRecordingTimeout();\r\n    }\r\n\r\n    // stop previous mediaStream track if exists\r\n    if (mediaStream.current) {\r\n      mediaStream.current.getAudioTracks()[0].stop();\r\n    }\r\n\r\n    // Clones stream to fix hark bug on Safari\r\n    mediaStream.current = stream.clone();\r\n\r\n    const speechEvents = Hark(mediaStream.current, {\r\n      audioContext: audioContextRef.current as AudioContext\r\n    });\r\n\r\n    speechEvents.on('speaking', () => {\r\n      if (onStartSpeaking) onStartSpeaking();\r\n\r\n      // Clear previous recording timeout on every speech event\r\n      clearTimeout(timeoutId.current);\r\n    });\r\n\r\n    speechEvents.on('stopped_speaking', () => {\r\n      if (onStoppedSpeaking) onStoppedSpeaking();\r\n\r\n      setIsRecording(false);\r\n      mediaStream.current?.getAudioTracks()[0].stop();\r\n\r\n      // Stops current recording and sends audio string to google cloud.\r\n      // recording will start again after google cloud api\r\n      // call if `continuous` prop is true. Until the api result\r\n      // returns, technically the microphone is not being captured again\r\n      stopRecording({\r\n        exportWAV: true,\r\n        wavCallback: (blob) =>\r\n          handleBlobToBase64({ blob, continuous: continuous || false })\r\n      });\r\n    });\r\n\r\n    setIsRecording(true);\r\n  };\r\n\r\n  const stopSpeechToText = () => {\r\n    if (recognition) {\r\n      recognition.stop();\r\n    } else {\r\n      setIsRecording(false);\r\n      mediaStream.current?.getAudioTracks()[0].stop();\r\n      stopRecording({\r\n        exportWAV: true,\r\n        wavCallback: (blob) => handleBlobToBase64({ blob, continuous: false })\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleRecordingTimeout = () => {\r\n    timeoutId.current = window.setTimeout(() => {\r\n      setIsRecording(false);\r\n      mediaStream.current?.getAudioTracks()[0].stop();\r\n      stopRecording({ exportWAV: false });\r\n    }, timeout);\r\n  };\r\n\r\n  const handleBlobToBase64 = ({\r\n    blob,\r\n    continuous\r\n  }: {\r\n    blob: Blob;\r\n    continuous: boolean;\r\n  }) => {\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(blob);\r\n\r\n    reader.onloadend = async () => {\r\n      const base64data = reader.result as string;\r\n\r\n      let sampleRate = audioContextRef.current?.sampleRate;\r\n\r\n      // Google only accepts max 48000 sample rate: if\r\n      // greater recorder js will down-sample to 48000\r\n      if (sampleRate && sampleRate > 48000) {\r\n        sampleRate = 48000;\r\n      }\r\n\r\n      const audio = { content: '' };\r\n\r\n      const config = {\r\n        encoding: 'LINEAR16',\r\n        languageCode: 'en-US',\r\n        sampleRateHertz: sampleRate\r\n      };\r\n\r\n      const data = {\r\n        config,\r\n        audio\r\n      };\r\n\r\n      // Gets raw base 64 string data\r\n      audio.content = base64data.substr(base64data.indexOf(',') + 1);\r\n\r\n      const googleCloudRes = await fetch(\r\n        `https://speech.googleapis.com/v1/speech:recognize?key=${googleApiKey}`,\r\n        {\r\n          method: 'POST',\r\n          body: JSON.stringify(data)\r\n        }\r\n      );\r\n\r\n      const googleCloudJson = await googleCloudRes.json();\r\n\r\n      // Update results state with transcribed text\r\n      if (googleCloudJson.results?.length > 0) {\r\n        setResults((prevResults) => [\r\n          ...prevResults,\r\n          googleCloudJson.results[0].alternatives[0].transcript\r\n        ]);\r\n      }\r\n\r\n      if (continuous) {\r\n        startSpeechToText();\r\n      }\r\n    };\r\n  };\r\n\r\n  return { results, startSpeechToText, stopSpeechToText, isRecording, error };\r\n}\r\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","__spreadArrays","s","i","il","arguments","r","Array","k","a","j","jl","audioContextType","WildEmitter","mixin","constructor","prototype","isWildEmitter","on","event","groupName","fn","callbacks","hasGroup","group","undefined","func","_groupName","once","self","off","releaseGroup","item","len","handlers","splice","indexOf","emit","listeners","args","slice","specialCallbacks","getWildcardCallbacks","concat","eventName","split","window","AudioContext","webkitAudioContext","audioContext","WORKER_ENABLED","global","URL","Blob","Worker","InlineWorker","functionBody","_this","toString","trim","match","createObjectURL","type","postMessage","data","setTimeout","onmessage","bind","Recorder","[object Object]","source","cfg","config","bufferLen","numChannels","mimeType","recording","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","onaudioprocess","buffer","channel","inputBuffer","getChannelData","worker","command","connect","destination","sampleRate","newSampleRate","recLength","recBuffers","initBuffers","mergeBuffers","Float32Array","offset","set","writeString","view","string","setUint8","charCodeAt","record","interleaved","buffers","inputL","inputR","index","inputIndex","interleave","dataview","samples","ArrayBuffer","DataView","setUint32","setUint16","output","input","Math","max","min","setInt16","floatTo16BitPCM","encodeWAV","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","downSampleBuffer","audioBlob","cb","callback","Error","blob","filename","url","webkitURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent","microphoneStream","rec","async","startRecording","errHandler","onStreamLoad","stream","navigator","mediaDevices","getUserMedia","audio","createMediaStreamSource","err","console","log","stopRecording","wavCallback","stop","getAudioTracks","clear","recognition","isEdgeChromium","userAgent","SpeechRecognition","webkitSpeechRecognition","useSpeechToText","_a","continuous","crossBrowser","googleApiKey","onStartSpeaking","onStoppedSpeaking","timeout","_b","useState","isRecording","setIsRecording","audioContextRef","useRef","_c","results","setResults","_d","error","setError","timeoutId","mediaStream","useEffect","current","startSpeechToText","start","onresult","prevResults","transcript","onaudiostart","onaudioend","state","resume","handleRecordingTimeout","clone","speechEvents","options","harker","sourceNode","fftBins","analyser","smoothing","interval","threshold","play","history","running","createAnalyser","fftSize","smoothingTimeConstant","frequencyBinCount","jquery","HTMLAudioElement","HTMLVideoElement","createMediaElementSource","speaking","suspend","Object","defineProperty","get","onstatechange","setThreshold","setInterval","disconnect","speakingHistory","looper","currentVolume","maxVolume","getFloatFrequencyData","ii","getMaxVolume","shift","Hark","clearTimeout","handleBlobToBase64","reader","FileReader","readAsDataURL","onloadend","base64data","encoding","languageCode","sampleRateHertz","content","substr","fetch","method","JSON","stringify","json","googleCloudJson","alternatives","stopSpeechToText","brave","isBrave","bool"],"mappings":"4DAmEO,SAASA,EAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,OAITO,KAAKR,EAAWK,GAClGH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,WAI/D,SAASO,EAAYjB,EAASkB,GACjC,IAAsGC,EAAGC,EAAGC,EAAGC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPJ,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOK,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEZ,KAAMkB,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAOC,OAAUX,EACvJ,SAASM,EAAKM,GAAK,OAAO,SAAUC,GAAK,OACzC,SAAcC,GACV,GAAIjB,EAAG,MAAM,IAAIkB,UAAU,mCAC3B,KAAOd,OACH,GAAIJ,EAAI,EAAGC,IAAMC,EAAY,EAARe,EAAG,GAAShB,EAAU,OAAIgB,EAAG,GAAKhB,EAAS,SAAOC,EAAID,EAAU,SAAMC,EAAEiB,KAAKlB,GAAI,GAAKA,EAAEV,SAAWW,EAAIA,EAAEiB,KAAKlB,EAAGgB,EAAG,KAAKtB,KAAM,OAAOO,EAE3J,OADID,EAAI,EAAGC,IAAGe,EAAK,CAAS,EAARA,EAAG,GAAQf,EAAEb,QACzB4B,EAAG,IACP,KAAK,EAAG,KAAK,EAAGf,EAAIe,EAAI,MACxB,KAAK,EAAc,OAAXb,EAAEC,QAAgB,CAAEhB,MAAO4B,EAAG,GAAItB,MAAM,GAChD,KAAK,EAAGS,EAAEC,QAASJ,EAAIgB,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKb,EAAEI,IAAIY,MAAOhB,EAAEG,KAAKa,MAAO,SACxC,QACI,KAAMlB,EAAIE,EAAEG,MAAML,EAAIA,EAAEmB,OAAS,GAAKnB,EAAEA,EAAEmB,OAAS,KAAkB,IAAVJ,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEb,EAAI,EAAG,SACjG,GAAc,IAAVa,EAAG,MAAcf,GAAMe,EAAG,GAAKf,EAAE,IAAMe,EAAG,GAAKf,EAAE,IAAM,CAAEE,EAAEC,MAAQY,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYb,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIA,EAAIe,EAAI,MAC7D,GAAIf,GAAKE,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIE,EAAEI,IAAIc,KAAKL,GAAK,MACvDf,EAAE,IAAIE,EAAEI,IAAIY,MAChBhB,EAAEG,KAAKa,MAAO,SAEtBH,EAAKlB,EAAKoB,KAAKtC,EAASuB,GAC1B,MAAOZ,GAAKyB,EAAK,CAAC,EAAGzB,GAAIS,EAAI,UAAeD,EAAIE,EAAI,EACtD,GAAY,EAARe,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAE5B,MAAO4B,EAAG,GAAKA,EAAG,QAAK,EAAQtB,MAAM,GArB9BL,CAAK,CAACyB,EAAGC,MAqEtD,SAASO,IACZ,IAAK,IAAIC,EAAI,EAAGC,EAAI,EAAGC,EAAKC,UAAUN,OAAQI,EAAIC,EAAID,IAAKD,GAAKG,UAAUF,GAAGJ,OACxE,IAAIO,EAAIC,MAAML,GAAIM,EAAI,EAA3B,IAA8BL,EAAI,EAAGA,EAAIC,EAAID,IACzC,IAAK,IAAIM,EAAIJ,UAAUF,GAAIO,EAAI,EAAGC,EAAKF,EAAEV,OAAQW,EAAIC,EAAID,IAAKF,IAC1DF,EAAEE,GAAKC,EAAEC,GACjB,OAAOJ,ECtIX,ICJIM,IDIaC,EAEjB,SAASA,KAETA,EAAYC,MAAQ,SAAUC,GAC1B,IAAIC,EAAYD,EAAYC,WAAaD,EAEzCC,EAAUC,eAAe,EAGzBD,EAAUE,GAAK,SAAUC,EAAOC,EAAWC,GACvC7B,KAAK8B,UAAY9B,KAAK8B,WAAa,GACnC,IAAIC,EAAiC,IAArBlB,UAAUN,OACtByB,EAAQD,EAAWlB,UAAU,QAAKoB,EAClCC,EAAOH,EAAWlB,UAAU,GAAKA,UAAU,GAG/C,OAFAqB,EAAKC,WAAaH,GACjBhC,KAAK8B,UAAUH,GAAS3B,KAAK8B,UAAUH,IAAU,IAAInB,KAAK0B,GACpDlC,MAKXwB,EAAUY,KAAO,SAAUT,EAAOC,EAAWC,GACzC,IAAIQ,EAAOrC,KACP+B,EAAiC,IAArBlB,UAAUN,OACtByB,EAAQD,EAAWlB,UAAU,QAAKoB,EAClCC,EAAOH,EAAWlB,UAAU,GAAKA,UAAU,GAC/C,SAASa,IACLW,EAAKC,IAAIX,EAAOD,GAChBQ,EAAKnD,MAAMiB,KAAMa,WAGrB,OADAb,KAAK0B,GAAGC,EAAOK,EAAON,GACf1B,MAIXwB,EAAUe,aAAe,SAAUX,GAE/B,IAAIY,EAAM7B,EAAG8B,EAAKC,EAClB,IAAKF,KAFLxC,KAAK8B,UAAY9B,KAAK8B,WAAa,GAEtB9B,KAAK8B,UAEd,IAAKnB,EAAI,EAAG8B,GADZC,EAAW1C,KAAK8B,UAAUU,IACCjC,OAAQI,EAAI8B,EAAK9B,IACpC+B,EAAS/B,GAAGwB,aAAeP,IAG3Bc,EAASC,OAAOhC,EAAG,GACnBA,IACA8B,KAIZ,OAAOzC,MAKXwB,EAAUc,IAAM,SAAUX,EAAOE,GAC7B7B,KAAK8B,UAAY9B,KAAK8B,WAAa,GACnC,IACInB,EADAmB,EAAY9B,KAAK8B,UAAUH,GAG/B,OAAKG,EAGoB,IAArBjB,UAAUN,eACHP,KAAK8B,UAAUH,GACf3B,QAKA,KADXW,EAAImB,EAAUc,QAAQf,MAElBC,EAAUa,OAAOhC,EAAG,GACK,IAArBmB,EAAUvB,eACHP,KAAK8B,UAAUH,IAGvB3B,MAhBgBA,MAqB3BwB,EAAUqB,KAAO,SAAUlB,GACvB3B,KAAK8B,UAAY9B,KAAK8B,WAAa,OAI/BnB,EACA8B,EAEAK,EANAC,EAAO,GAAGC,MAAM3C,KAAKQ,UAAW,GAChCiB,EAAY9B,KAAK8B,UAAUH,GAC3BsB,EAAmBjD,KAAKkD,qBAAqBvB,GAMjD,GAAIG,EAEA,IAAKnB,EAAI,EAAG8B,GADZK,EAAYhB,EAAUkB,SACMzC,OAAQI,EAAI8B,GAC/BK,EAAUnC,KAD4BA,EAI3CmC,EAAUnC,GAAG5B,MAAMiB,KAAM+C,GAIjC,GAAIE,EAGA,IAFAR,EAAMQ,EAAiB1C,OAElBI,EAAI,EAAG8B,GADZK,EAAYG,EAAiBD,SACDzC,OAAQI,EAAI8B,GAC/BK,EAAUnC,KAD4BA,EAI3CmC,EAAUnC,GAAG5B,MAAMiB,KAAM,CAAC2B,GAAOwB,OAAOJ,IAIhD,OAAO/C,MAIXwB,EAAU0B,qBAAuB,SAAUE,GACvCpD,KAAK8B,UAAY9B,KAAK8B,WAAa,GACnC,IAAIU,EACAa,EACAzE,EAAS,GAEb,IAAK4D,KAAQxC,KAAK8B,UACduB,EAAQb,EAAKa,MAAM,MACN,MAATb,GAAkC,IAAjBa,EAAM9C,QAAgB6C,EAAUJ,MAAM,EAAGK,EAAM,GAAG9C,UAAY8C,EAAM,MACrFzE,EAASA,EAAOuE,OAAOnD,KAAK8B,UAAUU,KAG9C,OAAO5D,IAKfyC,EAAYC,MAAMD,GCzII,oBAAXiC,SACTlC,EAAmBkC,OAAOC,cAAgBD,OAAOE,oBAGnD,IAAIC,EAAe,sJCrBfC,KAAoBC,IAAWA,EAAOL,QAAUK,EAAOC,KAAOD,EAAOE,MAAQF,EAAOG,QAExF,SAASC,EAAa7B,EAAMG,GAC1B,IACI2B,EADAC,EAAQjE,KAKZ,GAFAqC,EAAOA,GAAQ,GAEXqB,EAKF,OAJAM,EAAe9B,EAAKgC,WAAWC,OAAOC,MACpC,kDACA,GAEK,IAAIT,EAAOG,OAAOH,EAAOC,IAAIS,gBAClC,IAAIV,EAAOE,KAAK,CAAEG,GAAgB,CAAEM,KAAM,sBAU9CtE,KAAKqC,KAAOA,EACZrC,KAAKqC,KAAKkC,YAPV,SAAqBC,GACnBC,YAAW,WACTR,EAAMS,UAAU,CAAEF,KAAMA,MACvB,IAMLC,WAAWvC,EAAKyC,KAAKtC,EAAMA,GAAO,GAGpC0B,EAAavC,UAAU+C,YAAc,SAAqBC,GACxD,IAAIP,EAAQjE,KAEZyE,YAAW,WACTR,EAAM5B,KAAKqC,UAAU,CAAEF,KAAMA,MAC5B,IAGL,MAAiBT,ECpCV,MAAMa,EACXC,YAAYC,EAAQC,GAClB/E,KAAKgF,OAAS,CACZC,UAAW,KACXC,YAAa,EACbC,SAAU,eACPJ,GAEL/E,KAAKoF,WAAY,EACjBpF,KAAK8B,UAAY,CACfuD,UAAW,GACXC,UAAW,IAEbtF,KAAKuF,QAAUT,EAAOS,QACtBvF,KAAKwF,MACHxF,KAAKuF,QAAQE,uBAAyBzF,KAAKuF,QAAQG,sBACnDrF,KACAL,KAAKuF,QACLvF,KAAKgF,OAAOC,UACZjF,KAAKgF,OAAOE,YACZlF,KAAKgF,OAAOE,aAGdlF,KAAKwF,KAAKG,eAAkBjH,IAC1B,GAAKsB,KAAKoF,UAAV,CAGA,IADA,IAAIQ,EAAS,GACJC,EAAU,EAAGA,EAAU7F,KAAKgF,OAAOE,YAAaW,IACvDD,EAAOpF,KAAK9B,EAAEoH,YAAYC,eAAeF,IAE3C7F,KAAKgG,OAAOzB,YAAY,CACtB0B,QAAS,SACTL,OAAQA,MAIZd,EAAOoB,QAAQlG,KAAKwF,MACpBxF,KAAKwF,KAAKU,QAAQlG,KAAKuF,QAAQY,aAG/BnG,KAAKgG,OAAS,IAAIjC,GAAa,WAC7B,IAEEqC,EACAlB,EAsBEmB,EAzBAC,EAAY,EACdC,EAAa,GAgFf,SAASC,IACP,IAAK,IAAIX,EAAU,EAAGA,EAAUX,EAAaW,IAC3CU,EAAWV,GAAW,GAI1B,SAASY,EAAaF,EAAYD,GAChC,IAAI1H,EAAS,IAAI8H,aAAaJ,GAC1BK,EAAS,EACb,IAAK,IAAIhG,EAAI,EAAGA,EAAI4F,EAAWhG,OAAQI,IACrC/B,EAAOgI,IAAIL,EAAW5F,GAAIgG,GAC1BA,GAAUJ,EAAW5F,GAAGJ,OAE1B,OAAO3B,EAyBT,SAASiI,EAAYC,EAAMH,EAAQI,GACjC,IAAK,IAAIpG,EAAI,EAAGA,EAAIoG,EAAOxG,OAAQI,IACjCmG,EAAKE,SAASL,EAAShG,EAAGoG,EAAOE,WAAWtG,IApHhDX,KAAK0E,UAAY,SAAUhG,GACzB,OAAQA,EAAE8F,KAAKyB,SACb,IAAK,OAoBKjB,EAnBHtG,EAAE8F,KAAKQ,OAoBhBoB,EAAapB,EAAOoB,WACpBlB,EAAcF,EAAOE,YACrBsB,IAGEH,EADED,EAAa,KACC,KAEAA,EA1Bd,MACF,IAAK,UA6BT,SAAgBN,GACd,IAAK,IAAID,EAAU,EAAGA,EAAUX,EAAaW,IAC3CU,EAAWV,GAASrF,KAAKsF,EAAYD,IAEvCS,GAAaR,EAAY,GAAGvF,OAhCxB2G,CAAOxI,EAAE8F,KAAKoB,QACd,MACF,IAAK,aAiCT,SAAmBtB,GACjB,IAII6C,EAJAC,EAAU,GACd,IAAK,IAAIvB,EAAU,EAAGA,EAAUX,EAAaW,IAC3CuB,EAAQ5G,KAAKiG,EAAaF,EAAWV,GAAUS,IAI/Ca,EADkB,IAAhBjC,EA6CN,SAAoBmC,EAAQC,GAC1B,IAAI/G,EAAS8G,EAAO9G,OAAS+G,EAAO/G,OAChC3B,EAAS,IAAI8H,aAAanG,GAE1BgH,EAAQ,EACVC,EAAa,EAEf,KAAOD,EAAQhH,GACb3B,EAAO2I,KAAWF,EAAOG,GACzB5I,EAAO2I,KAAWD,EAAOE,GACzBA,IAEF,OAAO5I,EAxDS6I,CAAWL,EAAQ,GAAIA,EAAQ,IAE/BA,EAAQ,GAIxB,IAEIM,EAqGN,SAAmBC,GACjB,IAAI/B,EAAS,IAAIgC,YAAY,GAAsB,EAAjBD,EAAQpH,QACtCuG,EAAO,IAAIe,SAASjC,GA+BxB,OA5BAiB,EAAYC,EAAM,EAAG,QAErBA,EAAKgB,UAAU,EAAG,GAAsB,EAAjBH,EAAQpH,QAAY,GAE3CsG,EAAYC,EAAM,EAAG,QAErBD,EAAYC,EAAM,GAAI,QAEtBA,EAAKgB,UAAU,GAAI,IAAI,GAEvBhB,EAAKiB,UAAU,GAAI,GAAG,GAEtBjB,EAAKiB,UAAU,GAAI7C,GAAa,GAEhC4B,EAAKgB,UAAU,GAAIzB,GAAe,GAElCS,EAAKgB,UAAU,GAAoB,EAAhBzB,GAAmB,GAEtCS,EAAKiB,UAAU,GAAkB,EAAd7C,GAAiB,GAEpC4B,EAAKiB,UAAU,GAAI,IAAI,GAEvBlB,EAAYC,EAAM,GAAI,QAEtBA,EAAKgB,UAAU,GAAqB,EAAjBH,EAAQpH,QAAY,GA/EzC,SAAyByH,EAAQrB,EAAQsB,GACvC,IAAK,IAAItH,EAAI,EAAGA,EAAIsH,EAAM1H,OAAQI,IAAKgG,GAAU,EAAG,CAClD,IAAIjG,EAAIwH,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGH,EAAMtH,KACvCqH,EAAOK,SAAS1B,EAAQjG,EAAI,EAAQ,MAAJA,EAAiB,MAAJA,GAAY,IA8E3D4H,CAAgBxB,EAAM,GAAIa,GAEnBb,EAtIQyB,CAiEjB,SAA0B3C,EAAQ4C,GAChC,GAAIA,GAAQpC,EACV,OAAOR,EAET,GAAI4C,EAAOpC,EACT,KAAM,8DAER,IAAIqC,EAAkBrC,EAAaoC,EAC/BE,EAAYR,KAAKS,MAAM/C,EAAOrF,OAASkI,GACvC7J,EAAS,IAAI8H,aAAagC,GAC1BE,EAAe,EACfC,EAAe,EACnB,KAAOD,EAAehK,EAAO2B,QAAQ,CAOnC,IANA,IAAIuI,EAAmBZ,KAAKS,OACzBC,EAAe,GAAKH,GAGnBM,EAAQ,EACVC,EAAQ,EAEJrI,EAAIkI,EACRlI,EAAImI,GAAoBnI,EAAIiF,EAAOrF,OACnCI,IAEAoI,GAASnD,EAAOjF,GAChBqI,IAEFpK,EAAOgK,GAAgBG,EAAQC,EAG/BJ,IACAC,EAAeC,EAEjB,OAAOlK,EApGiBqK,CAAiB9B,EAAad,IAGlD6C,EAAY,IAAIrF,KAAK,CAAC6D,GAAW,CAAEpD,KAAMA,IAE7CtE,KAAKuE,YAAY,CAAE0B,QAAS,YAAazB,KAAM0E,IAlD3C5D,CAAU5G,EAAE8F,KAAKF,MACjB,MACF,IAAK,aAmDT,WACE,IAAI8C,EAAU,GACd,IAAK,IAAIvB,EAAU,EAAGA,EAAUX,EAAaW,IAC3CuB,EAAQ5G,KAAKiG,EAAaF,EAAWV,GAAUS,IAEjDtG,KAAKuE,YAAY,CAAE0B,QAAS,YAAazB,KAAM4C,IAvD3C/B,GACA,MACF,IAAK,QAyDPiB,EAAY,EACZC,EAAa,GACbC,IAnDF,IAAcxB,KA7BL,IAyMXhF,KAAKgG,OAAOzB,YAAY,CACtB0B,QAAS,OACTjB,OAAQ,CACNoB,WAAYpG,KAAKuF,QAAQa,WACzBlB,YAAalF,KAAKgF,OAAOE,eAI7BlF,KAAKgG,OAAOtB,UAAahG,IACvB,IAAIyK,EAAKnJ,KAAK8B,UAAUpD,EAAE8F,KAAKyB,SAAS3F,MACvB,mBAAN6I,GACTA,EAAGzK,EAAE8F,KAAKA,OAKhBK,SACE7E,KAAKoF,WAAY,EAGnBP,OACE7E,KAAKoF,WAAY,EAGnBP,QACE7E,KAAKgG,OAAOzB,YAAY,CAAE0B,QAAS,UAGrCpB,UAAUsE,GAER,KADAA,EAAKA,GAAMnJ,KAAKgF,OAAOoE,UACd,MAAM,IAAIC,MAAM,oBAEzBrJ,KAAK8B,UAAUuD,UAAU7E,KAAK2I,GAE9BnJ,KAAKgG,OAAOzB,YAAY,CAAE0B,QAAS,cAGrCpB,UAAUsE,EAAIhE,GAGZ,GAFAA,EAAWA,GAAYnF,KAAKgF,OAAOG,WACnCgE,EAAKA,GAAMnJ,KAAKgF,OAAOoE,UACd,MAAM,IAAIC,MAAM,oBAEzBrJ,KAAK8B,UAAUwD,UAAU9E,KAAK2I,GAE9BnJ,KAAKgG,OAAOzB,YAAY,CACtB0B,QAAS,YACT3B,KAAMa,IAIVN,qBAAqByE,EAAMC,GACzB,IAAIC,GAAOlG,OAAOM,KAAON,OAAOmG,WAAWpF,gBAAgBiF,GACvDI,EAAOpG,OAAOqG,SAASC,cAAc,KACzCF,EAAKG,KAAOL,EACZE,EAAKI,SAAWP,GAAY,aAC5B,IAAIQ,EAAQJ,SAASK,YAAY,SACjCD,EAAME,UAAU,SAAS,GAAM,GAC/BP,EAAKQ,cAAcH,ICzSvB,IAAII,EAEAlC,EADAmC,EAAMxF,EAYHyF,eAAeC,GAAe7G,aACnCA,EAAY8G,WACZA,EAAUC,aACVA,IAEA,IACE,MAAMC,QAAeC,UAAUC,aAAaC,aAAa,CAAEC,OAAO,IAiBlE,OAfIL,GACFA,IAIFL,EAAmBM,EAGnBxC,EAAQxE,EAAaqH,wBAAwBL,GAE7CL,EAAM,IAAIxF,EAASqD,GAGnBmC,EAAIlD,SAEGuD,EACP,MAAOM,GACPC,QAAQC,IAAIF,GAERR,GACFA,KAYC,SAASW,GAAc5F,UAAEA,EAAS6F,YAAEA,IAEzCf,EAAIgB,OAGJjB,EAAiBkB,iBAAiB,GAAGD,OAGjC9F,GAAa6F,GACff,EAAI9E,WAAWgE,GAAS6B,EAAY7B,KAGtCc,EAAIkB,QC/DN,IAaIC,EAbEC,GAA0D,IAAzCd,UAAUe,UAAU7I,QAAQ,QAQ7CW,EAAeD,OAAOC,cAAiBD,OAAeE,mBAEtDkI,EACJpI,OAAOoI,mBAAsBpI,OAAeqI,iCA4BtBC,EAAgBC,GAAxC,WACEC,eACAC,iBACAC,iBACAC,oBACAC,sBACAC,YAEMC,EAAgCC,GAAS,GAAxCC,OAAaC,OAEdC,EAAkBC,IAElBC,EAAwBL,EAAmB,IAA1CM,OAASC,OACVC,EAAoBR,EAAS,IAA5BS,OAAOC,OAERC,EAAYP,IACZQ,EAAcR,IAEpBS,GAAU,iBACHnB,GAAiBR,GACpBwB,EAAS,wEAGNrC,oBAAAA,iBAAAA,UAAWC,mCAAcC,eAC5BmC,EAAS,2DAGNP,EAAgBW,UACnBX,EAAgBW,QAAU,IAAI5J,KAE/B,IAIH,IA4BM6J,EAAoB,8GACxB,OAAI7B,GA5BAA,IAEEO,IAAYP,EAAYO,YAAa,GAGzCP,EAAY8B,QAGZ9B,EAAY+B,SAAW,SAAC5O,GAClBA,EAAEiO,SACJC,GAAW,SAACW,GAAgB,SACvBA,GACH7O,EAAEiO,QAAQjO,EAAEiO,QAAQpM,OAAS,GAAG,GAAGiN,iBAKzCjC,EAAYkC,aAAe,WAAM,OAAAlB,GAAe,IAIhDhB,EAAYmC,WAAa,WACvBnB,GAAe,UAWdR,GAMkC,yBAAnCS,EAAgBW,8BAASQ,mBAC3BnB,EAAgBW,wBAASS,aAGNtD,EAAe,CAClCC,WAAY,WAAM,OAAAwC,EAAS,qCAC3BtJ,aAAc+I,EAAgBW,8BAF1B1C,EAASiC,SAMXP,GACF0B,IAIEZ,EAAYE,SACdF,EAAYE,QAAQ9B,iBAAiB,GAAGD,OAI1C6B,EAAYE,QAAU1C,EAAOqD,SAEvBC,EJrHO,SAAStD,EAAQuD,GAChC,IAAIC,EAAS,IAAI5M,EAGjB,IAAKD,EAAkB,OAAO6M,EAG9B,IAWIC,EAAYC,EAASC,EAVrBC,GADAL,EAAUA,GAAW,IACAK,WAAa,GAClCC,EAAYN,EAAQM,UAAY,GAChCC,EAAYP,EAAQO,UACpBC,EAAOR,EAAQQ,KACfC,EAAUT,EAAQS,SAAW,GAC7BC,GAAU,EAGdjL,EAAeuK,EAAQvK,cAAgBA,GAAgB,IAAIrC,GAI3DgN,EAAW3K,EAAakL,kBACfC,QAAU,IACnBR,EAASS,sBAAwBR,EACjCF,EAAU,IAAIzH,aAAa0H,EAASU,mBAEhCrE,EAAOsE,SAAQtE,EAASA,EAAO,IAC/BA,aAAkBuE,kBAAoBvE,aAAkBwE,kBAE1Df,EAAazK,EAAayL,yBAAyBzE,QAC/B,IAAT+D,IAAsBA,GAAO,GACxCD,EAAYA,IAAc,KAG1BL,EAAazK,EAAaqH,wBAAwBL,GAClD8D,EAAYA,IAAc,IAG5BL,EAAWhI,QAAQkI,GACfI,GAAMJ,EAASlI,QAAQzC,EAAa0C,aAExC8H,EAAOkB,UAAW,EAElBlB,EAAOmB,QAAU,WACf,OAAO3L,EAAa2L,WAEtBnB,EAAOL,OAAS,WACd,OAAOnK,EAAamK,UAEtByB,OAAOC,eAAerB,EAAQ,QAAS,CAAEsB,IAAK,WAC5C,OAAO9L,EAAakK,SAEtBlK,EAAa+L,cAAgB,WAC3BvB,EAAOpL,KAAK,eAAgBY,EAAakK,QAG3CM,EAAOwB,aAAe,SAASrQ,GAC7BmP,EAAYnP,GAGd6O,EAAOyB,YAAc,SAAS/O,GAC5B2N,EAAW3N,GAGbsN,EAAO7C,KAAO,WACZsD,GAAU,EACVT,EAAOpL,KAAK,iBAAkB,IAAK0L,GAC/BN,EAAOkB,WACTlB,EAAOkB,UAAW,EAClBlB,EAAOpL,KAAK,qBAEduL,EAASuB,aACTzB,EAAWyB,cAEb1B,EAAO2B,gBAAkB,GACzB,IAAK,IAAIjP,EAAI,EAAGA,EAAI8N,EAAS9N,IACzBsN,EAAO2B,gBAAgBpP,KAAK,GAKhC,IAAIqP,EAAS,WACXpL,YAAW,WAGT,GAAIiK,EAAJ,CAIA,IAAIoB,EA5GV,SAAuB1B,EAAUD,GAC/B,IAAI4B,GAAY,EAAA,EAChB3B,EAAS4B,sBAAsB7B,GAE/B,IAAI,IAAIxN,EAAE,EAAGsP,EAAG9B,EAAQ5N,OAAQI,EAAIsP,EAAItP,IAClCwN,EAAQxN,GAAKoP,GAAa5B,EAAQxN,GAAK,IACzCoP,EAAY5B,EAAQxN,IAIxB,OAAOoP,EAkGiBG,CAAa9B,EAAUD,GAE3CF,EAAOpL,KAAK,gBAAiBiN,EAAevB,GAE5C,IAAIE,EAAU,EACd,GAAIqB,EAAgBvB,IAAcN,EAAOkB,SAAU,CAEjD,IAAK,IAAIxO,EAAIsN,EAAO2B,gBAAgBrP,OAAS,EAAGI,EAAIsN,EAAO2B,gBAAgBrP,OAAQI,IACjF8N,GAAWR,EAAO2B,gBAAgBjP,GAEhC8N,GAAW,IACbR,EAAOkB,UAAW,EAClBlB,EAAOpL,KAAK,kBAET,GAAIiN,EAAgBvB,GAAaN,EAAOkB,SAAU,CACvD,IAASxO,EAAI,EAAGA,EAAIsN,EAAO2B,gBAAgBrP,OAAQI,IACjD8N,GAAWR,EAAO2B,gBAAgBjP,GAErB,GAAX8N,IACFR,EAAOkB,UAAW,EAClBlB,EAAOpL,KAAK,qBAGhBoL,EAAO2B,gBAAgBO,QACvBlC,EAAO2B,gBAAgBpP,KAAK,GAAKsP,EAAgBvB,IAEjDsB,OACCvB,IAIL,OAFAuB,IAEO5B,EIFgBmC,CAAKnD,EAAYE,QAAS,CAC7C1J,aAAc+I,EAAgBW,WAGnBzL,GAAG,YAAY,WACtBuK,GAAiBA,IAGrBoE,aAAarD,EAAUG,YAGzBY,EAAarM,GAAG,oBAAoB,iBAC9BwK,GAAmBA,IAEvBK,GAAe,aACfU,EAAYE,wBAAS9B,iBAAiB,GAAGD,OAMzCF,EAAc,CACZ5F,WAAW,EACX6F,YAAa,SAAC7B,GACZ,OAAAgH,EAAmB,CAAEhH,OAAMwC,WAAYA,IAAc,UAI3DS,GAAe,eAgBXsB,EAAyB,WAC7Bb,EAAUG,QAAU7J,OAAOmB,YAAW,iBACpC8H,GAAe,aACfU,EAAYE,wBAAS9B,iBAAiB,GAAGD,OACzCF,EAAc,CAAE5F,WAAW,MAC1B6G,IAGCmE,EAAqB,SAACzE,OAC1BvC,SACAwC,eAKMyE,EAAS,IAAIC,WACnBD,EAAOE,cAAcnH,GAErBiH,EAAOG,UAAY,oHA2BM,OA1BjBC,EAAaJ,EAAO3R,QAEtBwH,YAAaoG,EAAgBW,8BAAS/G,aAIxBA,EAAa,OAC7BA,EAAa,MAWT5B,EAAO,CACXQ,OAPa,CACb4L,SAAU,WACVC,aAAc,QACdC,gBAAiB1K,GAKjByE,MAVIA,EAAQ,CAAEkG,QAAS,KAczBlG,EAAMkG,QAAUJ,EAAWK,OAAOL,EAAW/N,QAAQ,KAAO,MAE/BqO,MAC3B,yDAAyDjF,EACzD,CACEkF,OAAQ,OACRjS,KAAMkS,KAAKC,UAAU5M,aAID,SARDkI,SAQsB2E,sBAAvCC,EAAkB5E,oBAGpB4E,EAAgB3E,8BAASpM,QAAS,GACpCqM,GAAW,SAACW,GAAgB,SACvBA,GACH+D,EAAgB3E,QAAQ,GAAG4E,aAAa,GAAG/D,gBAI3C1B,GACFsB,iBAKN,MAAO,CAAET,UAASS,oBAAmBoE,iBAlFZ,iBACnBjG,EACFA,EAAYH,QAEZmB,GAAe,aACfU,EAAYE,wBAAS9B,iBAAiB,GAAGD,OACzCF,EAAc,CACZ5F,WAAW,EACX6F,YAAa,SAAC7B,GAAS,OAAAgH,EAAmB,CAAEhH,OAAMwC,YAAY,SA0EbQ,cAAaQ,SAvOjEpC,UAA6B+G,OAC/B/G,UAA6B+G,MAAMC,UAAU5S,MAAK,SAAC6S,GAC9CA,IAAMpG,EAAc,UAOvBC,GAAkBE,IACrBH,EAAc,IAAIG"}